/**
 * Description:
 *  马特是一位艾泽拉斯大陆的冒险者，他在冒险的途中遇到了一群狼。马特需要消灭所有狼才能存活。
 *  狼的数量有n只，它们排成一排，从左至右编号为1∼n。第i只狼的基础伤害是ai点，并且可以给和它相邻的狼增加bi点伤害。当马特消灭一只狼的时候，马特会受到这只狼的基础伤害，以及这只狼相邻的狼给它增加的伤害。被消灭的狼会消失，在它左右的狼会变成相邻的狼。
 *  例如有3只狼，它们的基础伤害分别是(3,5,7)，附加伤害分别是(8,12,2)。那么如果马特先消灭第2只狼，马特会受到第2只狼的基础伤害5，再加上第2只狼旁边的两只狼（这里是第1,3只）带来的附加伤害8+2，一共受到15点伤害。第2只狼被消灭后，原来的第1,3只会变成相邻。
 *  通过适当选择消灭所有狼的顺序，马特受到的伤害的最小值是多少？
 *
 * Input:
 *  第1行，1个正整数n
 *  第2行，n个正整数a1,a2,...,an
 *  第3行，n个正整数b1,b2,...,bn
 *
 * Output:
 *  马特受到的伤害的最小值
 *
 * Hints:
 *  1≤n≤300, 1≤ai,bi≤10000
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
3
3 5 7
8 12 2
 *
 *  output:
27
 *
 *  2):
 *  input:
10
1 3 5 7 9 2 4 6 8 10
9 4 1 2 1 2 1 4 5 1
 *
 *  output:
74
 *
 */

#include <cstring>
#include <iostream>
using namespace std;
int n, a[310], b[310], f[310][310];
// f[i][j]表示消灭[i,j]之间的狼受到伤害的最小值

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
    }
    memset(f, 0x3f, sizeof f);
    for (int i = 1; i <= n; i++) {
        f[i][i] = b[i - 1] + a[i] + b[i + 1];
    }
    for (int l = 2; l <= n; l++) {
        for (int i = 1; i + l - 1 <= n; i++) {
            int j = i + l - 1;
            f[i][i - 1] = f[j + 1][j] = 0;
            for (int k = i; k <= j; k++) { // 枚举最后一只被消灭的狼
                f[i][j] = min(f[i][j], f[i][k - 1] + f[k + 1][j] + b[i - 1] + a[k] + b[j + 1]);
            }
        }
    }
    cout << f[1][n] << endl;
    return 0;
}