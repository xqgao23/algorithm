/**
 * Description:
 *  在夏令营快结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会没有准备足够的空光盘，没法保证每个人都能拿到资料，怎么办呢？
 *  小猴分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！
 *  事实上，通过分析选手们的关系网，小猴发现有联系的同学之间，如果有一个人获得了资料，与他有关系的所有其他同学都能通过他获得资料！
 *  现在假设总共有N个营员，每个营员的编号为1到N。小猴已经统计出了学生们之间的关系，请你编写一个程序，根据学生们的关系，帮助小猴计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？
 *
 * Input:
 *  第一行包含两个正整数N,M，表示营员的数量和小猴统计出的关系数量。
 *  接下来M行，每行两个整数a,b。表示一条关系，注意：由于小猴的统计方法很随意，因此可能会把同一个关系统计多次，也可能会统计出某个同学和他自己有关系。
 *
 * Output:
 *  仅包含一个整数，表示组委会最少要刻多少光盘。
 *
 * Hints:
 *  1<N ≤10<5>, 1≤M ≤10<6>
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
5 4
1 3
1 2
2 3
4 5
 *
 *  output:
2
 *
 */

#include <iostream>
#include <vector>
using namespace std;
const int N = 1e5 + 10;

int n, m, vis[N], ans;
vector<int> g[N];

void dfs(int x)
{
    if (vis[x]) {
        return;
    }
    vis[x] = 1;
    for (int i = 0; i < g[x].size(); i++) {
        int y = g[x][i];
        dfs(y);
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            dfs(i);
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}