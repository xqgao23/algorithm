/**
 * Description:
 *  如今许多普通百姓家有了私家车，一些人喜爱自己驾车从一个城市到另一个城市旅游。自己驾车旅游时总会碰到加油和吃饭的问题，在出发之前，驾车人总要想方设法得到从一个城市到另一个城市路线上的加油站的列表，列表中包括了所有加油站的位置及其每升的油价（如3.25 元/L）。驾车者一般都有以下的习惯：
 *  每当驾驶员到达一个加油站时：
 *  1.如果油箱里的汽油已经不够达到下一个加油站或目的地，驾驶员必须在当前加油站停下来加油。
 *  2.如果汽油足够到达下一个加油站，但是油箱的汽油小于最大容量一半时，驾驶员可以选择加油或者不加油。
 *  3.如果汽油足够到达下一个加油站，且油箱的汽油大于等于最大容量一半时，驾驶员一定不会加油。
 *  每次加油一定会将油箱加满。驾驶员在等待加油的同时要花20元买吃的。
 *  驾驶员在出发时花费c元将油箱加满。现在要你帮忙做的就是编写一个程序，计算出驾车从一个城市到另一个城市的旅游在加油和吃饭方面最少的费用。
 *
 * Input:
 *  第一行是一个实数L，是从出发地到目的地的距离（单位：公里）。
 *  第二行是三个实数v,m,c和一个整数n，其中第一个实数v是汽车油箱的最大容量（单位：升）；第二个实数m是汽车每升油能行驶的公里数；第三个实数是c汽车在出发地加满油箱时花掉的费用（单位：元）；一个整数n是 1到50 间的数，表示从出发地到目的地线路上加油站的数目。
 *  接下来 n 行都是两个实数di，pi，第一个数表示从出发地到某一个加油站的距离（单位：公里）；第二个实数表示该加油站汽油的价格（单位：元）。
 *  数据保证驾驶员一定可以到达目的地。一条线路上的加油站根据其到出发地的距离递增排列，并且都不会大于从出发地到目的地的距离。
 *
 * Output:
 *  输出一个实数，最小的加油和吃饭费用，输出时四舍五入到0.1。
 *
 * Hints:
 *  1<=n<=50
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
600
40 8.5 128 3
200 3.52
350 3.45
500 365
 *
 *  output:
13133.2
 *
 */

#include <iostream>
using namespace std;
int n;
double L, v, m, c, d[60], p[60], ans = 1e9;

void dfs(int step, double oil, double cost)
{
    if (cost > ans) {
        return; // 剪枝
    }
    if (step > n) // 出口
    {
        ans = min(ans, cost);
        return;
    }
    double tmp = (d[step + 1] - d[step]) / m; // 到达下一个加油站所需油量
    if (oil >= tmp) { // 汽油足够到达下一个加油站 {
        if (oil >= v / 2) {
            dfs(step + 1, oil - tmp, cost); // 油箱的 汽油大于等于最大容量一半时
        } else { // 油箱的汽油小于最大容量一半时
            dfs(step + 1, oil - tmp, cost);
            dfs(step + 1, v - tmp, cost + 20 + (v - oil) * p[step]);
        }
    } else {// 汽油已经不够达到下一个加油站
        dfs(step + 1, v - tmp, cost + 20 + (v - oil) * p[step]);
    }
}

int main()
{
    cin >> L >> v >> m >> c >> n;
    for (int i = 1; i <= n; i++) {
        cin >> d[i] >> p[i];
    }
    d[n + 1] = L;
    dfs(0, v, c);
    printf("%.1lf\n", ans);
    return 0;
}