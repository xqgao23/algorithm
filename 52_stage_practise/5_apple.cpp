/**
 * Description:
 *  很少有人知道奶牛爱吃苹果。农夫约翰的农场上有 C(1≤C≤50) 棵苹果树（编号为 1∼C）， 每一棵树上都长满了苹果。
 *  奶牛贝茜无法摘下树上的苹果，所以她只能等待苹果从树上落下。但是，由于苹果掉到地上会摔烂，贝茜必须在半空中接住苹果（没有人爱吃摔烂的苹果）。贝茜吃东西很快，她接到苹果后仅用几秒钟就能吃完。
 *  每一分钟，C 棵苹果树其中的一棵会掉落一个苹果。贝茜已经过了足够的训练， 只要站在树下就一定能接住这棵树上掉落的苹果。同时，贝茜能够在树之间快速移动，不论两棵树距离多远，都可以瞬间移动到另一棵树，因此当苹果掉落时，她必定能够站到 C 棵树其中的一棵下面。此外，奶牛不愿意不停地往返于苹果树之间，因此会错过一些苹果。
 *  苹果每分钟掉落一个，共 T(1≤T≤2000) 分钟，贝茜最多愿意移动 W(1≤W≤100)次。现给出每分钟掉落苹果的树的编号，要求判定贝茜能够接住的最多苹果数。 开始时贝茜在 1 号树下。
 *
 * Input:
 *  第一行 3 个数，T 和 W 和 C。
 *  第二行 T 个数，代表在时刻 1∼T 苹果是从哪棵苹果树上掉下来的。
 *
 * Output:
 *  输出一行，一个数，为奶牛最多接到的苹果的数量。
 *
 * Hints:
 *  1≤T≤2000, 1≤W≤100, 1≤C≤50
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
5 2 3
2 1 1 3 3
 *
 *  output:
4
 *
 *  2):
 *  input:
7 2 4
4 3 2 4 1 4 2
 *
 *  output:
4
 *
 *  3):
 *  input:
5 1 1
1 1 1 1 1
 *
 *  output:
5
 *
 *  4):
 *  input:
14 5 7
6 4 2 1 3 4 5 4 5 4 7 5 6 7
 *
 *  output:
8
 *
 */

#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
int t, w, c, a[2010], f[2010][110][60];
// f[i][j][k] 表示前i个苹果，移动了j次，当前在第k棵树下可以接到的苹果的最大 数量

int main()
{
    cin >> t >> w >> c;
    for (int i = 1; i <= t; i++) {
        cin >> a[i];
    }
    memset(f, -0x3f, sizeof f);
    f[0][0][1] = 0;
    for (int i = 1; i <= t; i++) {
        for (int j = 0; j <= w; j++) {
            for (int k = 1; k <= c; k++) {                                  // 第i分钟不移动
                if (a[i] != k) {
                    f[i][j][k] = max(f[i][j][k], f[i - 1][j][k]);           // 不接苹果
                }
                if (a[i] == k) {
                    f[i][j][a[i]] = max(f[i][j][a[i]], f[i - 1][j][k] + 1); // 接苹果
                }
            }
            for (int k = 1; k <= c; k++) {                                  // 第i分钟移动(现在在第a[i]棵树下)
                if (j > 0) {
                    f[i][j][a[i]] = max(f[i][j][a[i]], f[i - 1][j - 1][k] + 1);
                }
            }
        }
    }
    int ans = 0;
    for (int j = 0; j <= w; j++) {
        for (int k = 1; k <= c; k++) {
            ans = max(ans, f[t][j][k]);
        }
    }
    // for (int k = 1; k <= c; k++)
    // ans = max(ans, f[t][min(w, t)][k]);
    cout << ans << endl;
    return 0;
}