/**
 * Description:
 *  知名美食家小A被邀请至ATM 大酒店，为其品评菜肴。 ATM 酒店为小A准备了 N 道菜肴，酒店按照为菜肴预估的质量从高到低给予1到N的顺序编号，预估质量最高的菜肴编号为1。
 *  由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 M 条形如“i 号菜肴‘必须’先于 j 号菜肴制作”的限制，我们将这样的限制简写为<i,j>。
 *  现在，酒店希望能求出一个最优的菜肴的制作顺序，使得小A能尽量先吃到质量高的菜肴：
 *  也就是说，
 *      (1)在满足所有限制的前提下，1号菜肴”尽量“优先制作；
 *      (2)在满足所有限制，1号菜肴”尽量“优先制作的前提下，2号菜肴”尽量“优先制作；
 *      (3)在满足所有限制，1号和2号菜肴”尽量“优先的前提下，3号菜肴”尽量“优先制作；
 *      (4)在满足所有限制，1号和2号和3号菜肴”尽量“优先的前提下，4号菜肴”尽量“优先制作；
 *      (5)以此类推。
 *  例1：共4道菜肴，两条限制<3,1>、<4,1>，那么制作顺序是 3,4,1,2。
 *  例2：共5道菜肴，两条限制<5,2>、 <4,3>，那么制作顺序是 1,5,2,4,3。
 *  例1里，首先考虑1，因为有限制<3,1>和<4,1>，所以只有制作完 3 和 4 后才能制作 1，而根据(3)，3 号又应“尽量”比 4 号优先，所以当前可确定前三道菜的制作顺序是 3,4,1；接下来考虑2，确定最终的制作顺序是 3,4,1,2。
 *  例2里，首先制作1是不违背限制的；接下来考虑 2 时有<5,2>的限制，所以接下来先制作 5 再制作 2；接下来考虑 3 时有<4,3>的限制，所以接下来先制作4再制作3，从而最终的顺序是 1,5,2,4,3。 现在你需要求出这个最优的菜肴制作顺序。无解输出”Impossible!“ （不含引号，首字母大写，其余字母小写）
 *
 * Input:
 *  第一行是一个正整数D，表示数据组数。 接下来是D组数据。 对于每组数据： 第一行两个用空格分开的正整数N和M，分别表示菜肴数目和制作顺序限制的条目数。 接下来M行，每行两个正整数x,y，表示“x号菜肴必须先于y号菜肴制作”的限制。（注意：M条限制中可能存在完全相同的限制）
 *
 * Output:
 *  输出文件仅包含 D 行，每行 N 个整数，表示最优的菜肴制作顺序，或者“Impossible!“表示无解（不含引号）。
 *
 *  Hints:
 *      N,M≤100000,D≤3。
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
3
5 4
5 4
5 3
4 2
3 2
3 3
1 2
2 3
3 1
5 2
5 2
4 3
 *
 *  output:
1 5 3 4 2
Impossible!
1 5 2 4 3
 *
 */

#include <iostream>
#include <queue>
#include <vector>
using namespace std;
const int N = 1e5 + 10;
int T, n, m, rud[N], ans[N], cnt;
vector<int> g[N];

bool topo_sort()
{
    priority_queue<int> q;
    cnt = 0;
    for (int i = 1; i <= n; i++)
        if (rud[i] == 0)
            q.push(i);
    while (q.size()) {
        int x = q.top();
        q.pop();
        ans[++cnt] = x;
        for (auto y : g[x])
            if (--rud[y] == 0)
                q.push(y);
    }
    return cnt == n;
}

int main()
{
    cin >> T;
    while (T--) {
        cin >> n >> m;
        for (int i = 1; i <= n; i++) {
            g[i].clear();
            rud[i] = 0;
        }
        for (int i = 1; i <= m; i++) {
            int x, y;
            cin >> x >> y;
            g[y].push_back(x);
            rud[x]++;
        }
        if (!topo_sort())
            cout << "Impossible!" << endl;
        else
            for (int i = n; i >= 1; i--)
                cout << ans[i] << " \n"[i == 1];
    }
    return 0;
}