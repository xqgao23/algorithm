/**
 * Description:
 *  乘法拼图是用一排牌来玩的，每一张牌都包含一个正整数。在移动过程中，玩家从这一行中取出一张牌，并按所取牌上的数字与左右两张牌上的数字的乘积来得分。不允许取出第一张和最后一张卡片。最后一次取牌结束后，这一排只剩下两张牌。
 *  我们的目标是采取某种顺序取牌以尽量减少总得分。
 *  例如，如果一行中的牌包含数字10,1,50,20,5，玩家可能会拿先拿一张1的牌，然后拿20和50的牌，这样的得分为10×1×50+50×20×5+10×50×5=500+5000+2500=8000
 *  如果它按照相反的顺序拿牌，即先拿50，再拿20，最后拿1，这样的得分为1×50×20+1×20×5+10×1×5=1000+100+50=1150
 *
 * Input:
 *  第一行为一个整数N(3≤N≤100)，表示卡牌的数量
 *  接下来N个数字，第i个数字ai(1≤ai≤100)表示第i张牌上的数字
 *
 * Output:
 *  一个数字，表示最少得分
 *
 * Hints:
 *  1≤N≤100, 0≤ai≤20
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
6
10 1 50 50 20 5
 *
 *  output:
3650
 *
 */

#include <cstring>
#include <iostream>

using namespace std;

int n, a[110], f[110][110];
// f[i][j] 表示取走(i,j)后的最小得分

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    memset(f, 0x3f, sizeof f);
    for (int i = 1; i <= n; i++) {
        f[i][i] = 0;
    }
    for (int i = 1; i < n; i++) {
        f[i][i + 1] = 0;
    }
    for (int l = 3; l <= n; l++) {
        for (int i = 1; i + l - 1 <= n; i++) {
            int j = i + l - 1;
            for (int k = i + 1; k < j; k++) { // 最后一次取a[k]
                f[i][j] = min(f[i][j], f[i][k] + f[k][j] + a[i] * a[k] * a[j]);
            }
        }
    }
    cout << f[1][n] << endl;
    return 0;
}