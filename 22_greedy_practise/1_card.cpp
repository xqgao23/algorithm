/**
 * Description:
 *  有N堆纸牌，编号分别为1,2,⋯,N。每堆上有若干张，但纸牌总数必为N的倍数。可以在任一堆上取若干张纸牌，然后移动。
 *  移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N的堆上取的纸牌，只能移到编号为N−1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。
 *  现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。
 *  例如N=4，4堆纸牌数分别为：1) 9 2) 8 3) 17 4) 6
 *  移动3次可达到目的：
 *  从 3) 取4张牌放到4) (9,8,13,10）-> 从 3)取3张牌放到 2)（9,11,10,10）-> 从 2)
 * 取1张牌放到1)（10,10,10,10）。
 *
 * Input:
 *  第一行为：N（N 堆纸牌，1≤N≤100）
 *  第二行为：A1, A2, …, An （N堆纸牌，每堆纸牌初始数，1≤Ai≤10000）
 *
 * Output:
 *  一行：即所有堆均达到相等时的最少移动次数。
 *
 * Hints:
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
4
9 8 17 6
 *
 *  output:
3
 *
 */

#include <iostream>
using namespace std;
int n, s, a[110], ans;

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        s += a[i];
    }
    s /= n;
    for (int i = 1; i <= n; i++) {
        if (a[i] == s) {
            continue;
        }
        a[i + 1] += a[i] - s;
        ans++;
    }
    cout << ans << endl;
    return 0;
}