/**
 * Description:
 *  小春喜爱多年的球队进入了世界总决赛，为了给球员们加油打气，球迷们决定组织一场加油秀。
 *  在加油秀过程中，球迷们会穿着红色、绿色、蓝色三种队服中的一种·，排成一个N行M列的方阵，方阵需要按照球迷们穿的队服颜色划分成三个部分，一个成功的方阵要求如下：
 *  从第一行开始若干行（至少一行）的格子全部是红色的；
 *  接下来若干行（至少一行）的格子全部是绿色的；
 *  剩下的行（至少一行）全部是蓝色的。
 *  由于事前通知不到位，所有球迷都是随机穿了一种颜色的队服。现在方阵已经排好了，因此只能让穿错颜色的球迷们更换队服。小春希望合理地设计三种颜色的范围，使得需要换衣服的球迷尽可能少，作为小春的助理，你决定帮他完成任务！
 *
 * Input:
 *  输入有N+1行，第一行为两个正整数N,M，表示方阵的行数和列数。
 *  接下来N行，每行M个数字，表示方阵中当前位置的球迷穿着的队服颜色，其中0表示红色，1表示绿色，2表示蓝色。
 *
 * Output:
 *  输出一行一个整数，表示需要换衣服的球迷数量的最小值。
 *
 * Hints:
 *  0 < n,m <= 1000
 */

/**
 *  Samples:
 *  1):
 *  input:
5 5
1 2 0 0 2
1 0 2 2 1
2 1 2 1 1
0 2 0 2 1
1 0 2 2 2
 *
 *  output:
13
 *
 *  2):
 *  input:
7 5
0 1 0 0 1
1 2 0 2 1
1 0 0 0 0
1 1 0 2 1
0 2 0 2 0
1 2 1 1 2
0 1 2 2 2
 *
 *  output:
17
 */

#include <iostream>
using namespace std;
int n, m, x, sum[1010][3];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> x;
            sum[i][x]++;
        }
    }
    int ans = n * m;
    for (int i = 1; i <= n - 2; i++) {
        int s0 = 0, s1 = 0, s2 = 0;
        for (int j = 1; j <= i; j++) { // 前i行全部修改成红色的修改次数
            s0 += sum[j][1] + sum[j][2];
        }
        for (int j = i + 1; j <= n; j++) { // 记录第i+1~n行全部变为绿色的修改次数
            s1 += sum[j][0] + sum[j][2];
        }
        for (int j = n; j > i + 1; j--) // 枚举绿色和蓝色的分界线j:i+1~j-1是绿色，j~n是蓝色
        {

            s1 -=
                sum[j][0] + sum[j][2]; // 减去原来加上的第j行中修改为绿色的次数
            s2 += sum[j][0] + sum[j][1]; // 加上将第j行修改为蓝色的修改次数
            ans = min(ans, s0 + s1 + s2);
        }
    }
    cout << ans << endl;
    return 0;
}