/**
 * Description:
 *  兔子先生大学毕业后找到了一份实习工作，如果实习通过它就能转正了。
 *  实习期共有N天，其中有几天公司集体放假，兔子先生不用上班，剩下时间它可以选择工作或者休息。
 *  兔子先生工作总是越来越累，可是每当它休息时，它就重新充满了能量。简而言之，兔子先生第一天工作时这一天会消耗体力1，连续第二天工作时这一天会消耗体力2，连续第三天工作时这一天会消耗体力3，以此类推......
 *  每当兔子先生休息后，工作的第一天又会消耗体力1。
 *  为了让boss满意，兔子先生想工作尽量多的天数，但是懒惰的兔子先生又想让自己的总体力消耗不超过K
 *
 * Input:
 *  第一行两个整数N(1≤N≤400)和K(1≤K≤E<N>)，表示一共有N天，以及总体力不超过K。
 *  第二行是一个长度为N的01字符串。如果第i个字符为1，表示第i天兔子先生可以选择工作或者休息，如果第i个字符为0，则表示公司这天集体放假，兔子先生休息。
 *
 * Output:
 *  输出一行，包含一个整数，表示兔子先生最多能工作的天数。
 *
 * Hints:
 *  1≤n≤10<5>, 1≤ai≤10<9>
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
4 2
1011
 *
 *  output:
2
 *
 */

#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
int n, m, a[410], f[2][410][410];
// f[i][j][k] 表示前i天中工作了恰好j天，且当前连续工作了k天时，消耗的最小体 力

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%1d", &a[i]);
    }
    memset(f, 0x3f, sizeof f);
    f[0][0][0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= i; j++) {
            for (int k = 0; k <= j; k++) {         // 第i天不工作
                f[i & 1][j][0] = min(f[i & 1][j][0], f[i - 1 & 1][j][k]);
            }
            for (int k = 1; k <= j && a[i]; k++) { // 第i天工作
                f[i & 1][j][k] = min(f[i & 1][j][k], f[i - 1 & 1][j - 1][k - 1]) + k;
            }
        }
    }
    for (int i = n; i >= 0; i--) {
        for (int j = 0; j <= i; j++) {
            if (f[n & 1][i][j] <= m) {
                cout << i << endl;
                return 0;
            }
        }
    }
    return 0;
}