/**
 * Description:
 *  Farmer John最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。
 *  所有N(1≤N≤20)头奶牛都有一个确定的身高Hi(1≤H≤1,000,000)。设所有奶牛身高的和为S。书架的高度为B，并且保证1≤B≤S。
 *  为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不像演杂技一般，一头站在另一头的背上，叠成一座"奶牛塔"。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。
 *  塔叠得越高便越不稳定，于是奶牛们希望找到一种方案，使得叠出的塔在高度不小于书架高度的情况下，高度尽可能小。你也可以猜到你的任务了：写一个程序，计算奶牛们叠成的塔在满足要求的情况下，最少要比书架高多少。
 *
 * Input:
 *  第1行: 2个用空格隔开的整数：N和B
 *  第2..N+1行: 第i+1行是1个整数：Hi
 *
 * Output:
 *  第1行: 输出1个非负整数，即奶牛们叠成的塔最少比书架高的高度
 *
 * Hints:
 *  
 */

/**
 *  Samples:
 *  1):
 *  input:
5 16
3
1
3
5
6
 *
 *  output:
1
 *
 */

#include <iostream>
using namespace std;
int n, b, ans = 1e9, h[30], p[30];

void dfs(int step)
{
    if (step > n) {
        int s = 0;
        for (int i = 1; i <= n; i++) {
            if (p[i]) {
                s += h[i];
            }
        }
        if (s >= b) {
            ans = min(ans, s - b);
        }
        return;
    }
    for (int i = 0; i <= 1; i++) {
        p[step] = i;
        dfs(step + 1);
    }
}

int main()
{
    cin >> n >> b;
    for (int i = 1; i <= n; i++) {
        cin >> h[i];
    }
    dfs(1);
    cout << ans << endl;
    return 0;
}