/**
 * Description:
 *  卡布列克是一位数学家，他在研究数字时发现：任意一个不是用完全相同数字组成的四位数，如果对它们的每位数字重新排序，组成一个较大的数和一个较小的数，然后用较大数减去较小数，差不够四位数时补零，类推下去，最后将变成一个固定的数：6174，这就是卡布列克常数。
 *  例如：
 *  4321−1234=3087
 *  8730−378=8352
 *  8532−2358=6174
 *  7641−1467=6174
 *  如果K位数也照此办理，它们不是变成一个数，而是在几个数字之间形成循环，称作卡布列克圆舞曲。例如对于五位数
 *  54321−12345=41976
 *  97641−14679=82962
 *  98622−22689=75933
 *  97533−33579=63954
 *  96543−34569=61974
 *  97641−14679=82962
 *  我们把82962,75933,63954,61974称作循环节，即卡布列克圆舞曲。
 *
 * Input:
 *  输入第一行为一个正整数k, 表示位数. (k≤18)
 *  第二行为一个k位正整数正整数N. 表示待求"卡布列克圆舞曲"的起始整数
 *
 * Output:
 *  为对应整数的循环节，数据之间用空格隔开。
 *
 * Hints:
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
5
54321
 *
 *  output:
82962 75933 63954 61974
 *
 *  2):
 *  input:
4
4321
 *
 *  output:
6174
 */

#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

long long n, a[1010];
int k, b[20], cnt;

int main()
{
    cin >> k >> n;

    while (true) {
        a[++cnt] = n;

        // 拆位，把每一位数字先放到数组中
        int m = 0;
        while (n != 0) {
            int x = n % 10;
            n /= 10;
            b[++m] = x;
        }

        sort(b + 1, b + k + 1); // 从小到大排序
        long long x = 0, y = 0; // x表示较小的整数，y表示较大的整数
        
        for (int i = 1; i <= k; i++) {
            x = x * 10 + b[i]; // 重组较小的整数
        }
        
        for (int i = k; i >= 1; i--) {
            y = y * 10 + b[i]; // 重组较大的整数
        }

        n = y - x;             // 差值
        bool flag = false;
        for (int i = 1; i <= cnt; ++i) {
            if (a[i] == n) {
                for (int j = i; j <= cnt; j++) {
                    cout << a[j] << " ";
                }
                flag = true;
                break;
            }
        }
        if (flag) {
            break;
        }
    }

    return 0;
}