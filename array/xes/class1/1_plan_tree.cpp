/**
 * Description:
 *  校门外整齐的种了一些树, 这些树排列为n行m列, 并且编号为1 - (n * m). 不过这些树并非根据编号排列的.
 *  植树大师小然检查了一下数的编号, 他不喜欢, 于是决定把两棵树的位置互换一下.
 *  你现在知道树的初始排列方式, 又知道小然打算把哪两个位置的树互换, 你能预知换完之后树的排列方式吗?
 * 
 * Input:
 *  输入由n+2行组成:
 *  第1行, 2个以空格隔开的正整数n,m, 表示数共有n行m列.
 *  之后n行, 依次表示第1,2,...,n行的数; 其中每行m个以空格隔开的正整数, 表示这一行的第1,2,...,m颗树的编号. 保证编号是1 - (n*m)各一个.
 *  之后1行, 4个以空格隔开的正整数r1,c1,r2,c2, 表示小然打算把第r1行第c1列的树与第r2行第c2列的树交换.
 * 
 * Output:
 *  输出展示了交换后树的排列情况：
 *  输出共n行, 依次表示第1,2,...,n行的树; 其中每行m个以空格隔开的正整数,表示这一行的第1,2,...,m颗树的编号.
 * 
 * Hints:
 *  3 <= r1, r2 <= n <= 20; 3 <= c1, c2 <= m <= 20;
 *  所有编号是1 - (n*m) 范围内的正整数, 且保证是 1 - (n*m) 各一个.
 * 
 * Samples:
 *  1):
 *  input:
 *  3 3
 *  1 2 3
 *  4 5 6
 *  9 8 7
 *  1 1 2 3
 * 
 *  output:
 *  6 2 3
 *  4 5 1
 *  9 8 7
 */

#include <cstdio>
#include <iostream>
#include <algorithm>

using namespace std;

int n, m, a[25][25];
int r1, c1, r2, c2;

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
        }
    }
    
    cin >> r1 >> c1 >> r2 >> c2;
    
    swap(a[r1][c1], a[r2][c2]);

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cout << a[i][j] << ' ';
        }
        cout << endl;
    }
    
    return 0;
}