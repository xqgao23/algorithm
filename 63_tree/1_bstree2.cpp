/**
 * Description:
 *  二叉查找树又称二叉搜索树，树中每个结点最多有两个儿子，树上每个结点都有自己的数值，设key[p]表示结点p上的数值。二叉查找树具有这样的性质：对于其中的每个结点p，若其存在左孩子lch，则有key[lch]<key[p]；若其存在右孩子rch，则有key[p]<key[rch]。最终，对于树中的每个结点，其左子树所有结点的数值都比自己小，右子树所有结点的数值都比自己大。
 *  由于二叉查找树有许多特殊的性质，因此我们常常需要把一个普通的数组建成一棵二叉查找树，以完成各种特殊的操作。
 *  通常我们使用插入法来构建二叉查找树，一开始是一个空树，插入的第一个数就设为树的根节点。
 *  在非空的二叉查找树中插入一个数x时，我们通常使用递归的方法插入。首先从根节点u开始，把x插入到以u为根的子树上时，如果当前数x比key[u]小，则继续将x插入到u的左子树；否则将x插入到u的右子树；重复上述步骤，直到当前子树为空时，把x插入到当前位置。
 *  可以发现，即使是同样的数字，由于插入顺序不同，形成的二叉查找树的形态也会发生变化，现在给定一个数组，请你求出按照该顺序形成的二叉查找树的中序遍历和后序遍历。
 *
 * Input:
 *  第一行一个正整数n表示插入次数，初始二叉树为空树。
 *  第二行n个正整数用空格分隔开，表示每次插入的数字的值，保证输入数据各不相同。
 *
 * Output:
 *  第一行n个空格分隔的正整数，表示形成的二叉查找树的中序遍历。
 *  第二行n个空格分隔的正整数，表示形成的二叉查找树的后序遍历。
 *
 * Hints:
 *  N≤10<5>。输入的所有数字不大于10<9>。数据为随机构造。
 *
 */

/**
 *  Samples:
 *  1):
 *  input:
5
3 1 4 2 5
 *
 *  output:
1 2 3 4 5
2 1 5 4 3
 *
 *  2):
 *  input:
7
10 2 5 6 7 8 9
 *
 *  output:
2 5 6 7 8 9 10
9 8 7 6 5 2 10
 *
 *  3):
 *  input:
7
6 7 10 8 2 5 9
 *
 *  output:
2 5 6 7 8 9 10
5 2 9 8 10 7 6
 *
 */

// 方法二
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
int n, w[N], fa[N], lc[N], rc[N], root;

void insert(int x, int s)
{
    if (w[s] < w[x]) {
        if (lc[x]) {
            insert(lc[x], s);
        } else {
            lc[x] = s;
        }
    } else {
        if (rc[x]) {
            insert(rc[x], s);
        } else {
            rc[x] = s;
        }
    }
}

void dfs1(int x)
{
    if (lc[x]) {
        dfs1(lc[x]);
    }
    cout << w[x] << " ";
    if (rc[x]) {
        dfs1(rc[x]);
    }
}

void dfs2(int x)
{
    if (lc[x]) {
        dfs2(lc[x]);
    }
    if (rc[x]) {
        dfs2(rc[x]);
    }
    cout << w[x] << " ";
}

int main()
{
    cin >> n >> w[1];
    for (int i = 2; i <= n; i++) {
        cin >> w[i];
        insert(1, i);
    }
    dfs1(1);
    puts("");
    dfs2(1);
    return 0;
}